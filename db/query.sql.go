// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createOpinion = `-- name: CreateOpinion :one
INSERT INTO opinions (
    user_id, subject_type, subject_id, opinion, rating
) VALUES (
    $1, $2, $3, $4, $5
)
RETURNING id, user_id, subject_type, subject_id, opinion, rating, created_at, updated_at
`

type CreateOpinionParams struct {
	UserID      int64
	SubjectType string
	SubjectID   int64
	Opinion     string
	Rating      pgtype.Int4
}

func (q *Queries) CreateOpinion(ctx context.Context, arg CreateOpinionParams) (Opinion, error) {
	row := q.db.QueryRow(ctx, createOpinion,
		arg.UserID,
		arg.SubjectType,
		arg.SubjectID,
		arg.Opinion,
		arg.Rating,
	)
	var i Opinion
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SubjectType,
		&i.SubjectID,
		&i.Opinion,
		&i.Rating,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users(name,email,password)
VALUES($1,$2,$3)
RETURNING id
`

type CreateUserParams struct {
	Name     string
	Email    string
	Password string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (int64, error) {
	row := q.db.QueryRow(ctx, createUser, arg.Name, arg.Email, arg.Password)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const deleteOpinion = `-- name: DeleteOpinion :exec
DELETE FROM opinions
WHERE id = $1
`

func (q *Queries) DeleteOpinion(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteOpinion, id)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users 
WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteUser, id)
	return err
}

const getOpinion = `-- name: GetOpinion :one
SELECT id, user_id, subject_type, subject_id, opinion, rating, created_at, updated_at FROM opinions
WHERE id = $1
`

func (q *Queries) GetOpinion(ctx context.Context, id int64) (Opinion, error) {
	row := q.db.QueryRow(ctx, getOpinion, id)
	var i Opinion
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SubjectType,
		&i.SubjectID,
		&i.Opinion,
		&i.Rating,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUser = `-- name: GetUser :one
SELECT id,name,email 
FROM users 
WHERE id = $1
`

type GetUserRow struct {
	ID    int64
	Name  string
	Email string
}

func (q *Queries) GetUser(ctx context.Context, id int64) (GetUserRow, error) {
	row := q.db.QueryRow(ctx, getUser, id)
	var i GetUserRow
	err := row.Scan(&i.ID, &i.Name, &i.Email)
	return i, err
}

const getUsers = `-- name: GetUsers :many
SELECT id,name,email 
FROM users
`

type GetUsersRow struct {
	ID    int64
	Name  string
	Email string
}

func (q *Queries) GetUsers(ctx context.Context) ([]GetUsersRow, error) {
	rows, err := q.db.Query(ctx, getUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersRow
	for rows.Next() {
		var i GetUsersRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Email); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOpinions = `-- name: ListOpinions :many
SELECT id, user_id, subject_type, subject_id, opinion, rating, created_at, updated_at
FROM opinions
WHERE
    -- filtering
    ($1::text IS NULL OR subject_type = $1) AND
    ($2::bigint IS NULL OR subject_id = $2) AND
    ($3::bigint IS NULL OR user_id = $3) AND
    -- searching
    ($4::text IS NULL OR opinion ILIKE '%' || $4 || '%')
ORDER BY created_at DESC
LIMIT $5 OFFSET $6
`

type ListOpinionsParams struct {
	Column1 string
	Column2 int64
	Column3 int64
	Column4 string
	Limit   int32
	Offset  int32
}

func (q *Queries) ListOpinions(ctx context.Context, arg ListOpinionsParams) ([]Opinion, error) {
	rows, err := q.db.Query(ctx, listOpinions,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Opinion
	for rows.Next() {
		var i Opinion
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SubjectType,
			&i.SubjectID,
			&i.Opinion,
			&i.Rating,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOpinion = `-- name: UpdateOpinion :one
UPDATE opinions
SET opinion = $2,
    rating = $3,
    updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, subject_type, subject_id, opinion, rating, created_at, updated_at
`

type UpdateOpinionParams struct {
	ID      int64
	Opinion string
	Rating  pgtype.Int4
}

func (q *Queries) UpdateOpinion(ctx context.Context, arg UpdateOpinionParams) (Opinion, error) {
	row := q.db.QueryRow(ctx, updateOpinion, arg.ID, arg.Opinion, arg.Rating)
	var i Opinion
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SubjectType,
		&i.SubjectID,
		&i.Opinion,
		&i.Rating,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users 
SET name = $2, email = $3 
WHERE id = $1 
RETURNING id,name,email
`

type UpdateUserParams struct {
	ID    int64
	Name  string
	Email string
}

type UpdateUserRow struct {
	ID    int64
	Name  string
	Email string
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (UpdateUserRow, error) {
	row := q.db.QueryRow(ctx, updateUser, arg.ID, arg.Name, arg.Email)
	var i UpdateUserRow
	err := row.Scan(&i.ID, &i.Name, &i.Email)
	return i, err
}
